<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>jurek36AI Chatbot</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
  <style>
    /* Custom scrollbar for better appearance */
    #chat::-webkit-scrollbar {
      width: 8px;
    }
    #chat::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
    }
    #chat::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 10px;
    }
    #chat::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.5);
    }

    /* Animated Gradient Background */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Inter', sans-serif;
      background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);
      background-size: 400% 400%;
      animation: gradientAnimation 15s ease infinite;
      color: #333;
    }

    @keyframes gradientAnimation {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    .page-wrapper {
        display: flex;
        flex-direction: column; /* Ustawiamy elementy pionowo */
        align-items: center; /* Centrujemy w poziomie */
        min-height: 100vh;
        padding: 1rem;
        width: 100%;
        box-sizing: border-box; /* Upewnij się, że padding nie rozszerza elementu */
    }

    .chat-container {
        width: 100%;
        max-width: 500px;
        background-color: rgba(255, 255, 255, 0.95);
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        border-radius: 1rem;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        height: 90vh;
        max-height: 700px;
        margin-top: 1rem; /* Dodajemy margines od góry (jeśli reklama jest na górze) */
        margin-bottom: 1rem; /* Dodajemy margines od dołu (jeśli reklama jest na dole) */
    }

    .ad-container {
        width: 100%;
        max-width: 500px; /* Dopasuj szerokość do szerokości kontenera czatu */
        margin: 1rem auto; /* Centruj i dodaj margines */
        text-align: center; /* Centruj reklamę w poziomie */
    }


    .chat-header {
      background: rgba(59, 130, 246, 0.9);
      color: white;
      padding: 1.25rem;
      font-size: 1.25rem;
      font-weight: 600;
      text-align: center;
      border-top-left-radius: 1rem;
      border-top-right-radius: 1rem;
    }

    .chat-main {
        flex: 1;
        padding: 1rem;
        overflow-y: auto;
        background-color: rgba(249, 250, 251, 0.8);
    }
    .chat-main > div {
        margin-bottom: 0.75rem;
    }

    .chat-footer {
        padding: 1rem;
        background-color: rgba(255, 255, 255, 0.95);
        border-top: 1px solid #e5e7eb;
        display: flex;
    }

    .input-row {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        width: 100%;
    }

    .chat-input {
        flex: 1;
        padding: 0.75rem 1rem;
        border: 1px solid #d1d5db;
        border-radius: 0.5rem;
        outline: none;
        transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        font-size: 0.875rem;
    }

    .chat-input:focus {
        border-color: #3b82f6;
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
    }
    .chat-input:disabled {
        background-color: #f3f4f6;
        cursor: not-allowed;
    }

    .chat-send-button {
        padding: 0.75rem 1.25rem;
        background-color: #3b82f6;
        color: white;
        border-radius: 0.5rem;
        transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
        border: none;
        cursor: pointer;
        font-weight: 500;
        font-size: 0.875rem;
    }

    .chat-send-button:hover {
        background-color: #2563eb;
    }
    .chat-send-button:active {
        transform: scale(0.98);
    }
    .chat-send-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
    }

    .message-bubble {
      display: inline-block;
      padding: 0.625rem 1rem;
      border-radius: 0.75rem;
      max-width: 85%;
      word-wrap: break-word;
      white-space: pre-wrap;
      font-size: 0.875rem;
      line-height: 1.5;
    }

    .message-bubble.user {
      background-color: #3b82f6;
      color: white;
      border-top-right-radius: 0.25rem;
    }

    .message-bubble.bot {
      background-color: #e5e7eb;
      color: #1f2937;
      border-top-left-radius: 0.25rem;
    }

    .message-bubble img {
        max-width: 100%;
        border-radius: 0.5rem;
        margin-top: 0.75rem;
        display: block;
        border: 1px solid #d1d5db;
    }
    .image-caption {
        font-size: 0.75rem;
        color: #6b7280;
        margin-top: 0.375rem;
        display: block;
        text-align: center;
    }

    .message-bubble pre {
      background-color: rgba(209, 213, 219, 0.9);
      padding: 0.75rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      position: relative;
      margin-top: 0.5rem;
      margin-bottom: 0.5rem;
      line-height: 1.4;
      color: #111827;
      font-size: 0.8125rem;
    }

    .message-bubble pre code {
      font-family: 'Fira Code', 'Cascadia Code', 'Source Code Pro', monospace;
      display: block;
    }

    .message-bubble strong { font-weight: 600; }
    .message-bubble em { font-style: italic; }
    .message-bubble a { color: #2563eb; text-decoration: underline; }
    .message-bubble ul, .message-bubble ol { list-style-position: inside; padding-left: 1.25rem; margin-bottom: 0.5rem; }
    .message-bubble li { margin-bottom: 0.25rem; }
    .message-bubble h1, .message-bubble h2, .message-bubble h3, .message-bubble h4, .message-bubble h5, .message-bubble h6 {
      font-weight: 600; margin-top: 1rem; margin-bottom: 0.5rem; line-height: 1.3; color: #1f2937;
    }
    .message-bubble h1 { font-size: 1.25rem; }
    .message-bubble h2 { font-size: 1.125rem; }
    .message-bubble h3 { font-size: 1rem; }
    .message-bubble p { margin-bottom: 0.5rem; }

    .typing-indicator span { animation: blink 1.2s infinite; }
    .typing-indicator span:nth-child(2) { animation-delay: 0.25s; }
    .typing-indicator span:nth-child(3) { animation-delay: 0.5s; }

    @keyframes blink {
        0%, 80%, 100% { opacity: 0.3; }
        40% { opacity: 1; }
    }
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap');
  </style>
</head>
<body>
  <div class="page-wrapper">

    <div class="chat-container">
      <header class="chat-header">
        <h1>jurek36AI Chatbot</h1>
      </header>
      <main id="chat" class="chat-main">
        </main>
      <footer class="chat-footer">
        <div class="input-row">
            <input id="message" type="text" placeholder="Napisz wiadomość lub /obraz <opis>..."
                   class="chat-input" />
            <button id="send" class="chat-send-button">
              Wyślij
            </button>
        </div>
      </footer>
    </div>

    </div> <script>
    // !!! === BARDZO WAŻNE OSTRZEŻENIE BEZPIECZEŃSTWA === !!!
    // PONIŻEJ ZNAJDUJE SIĘ TWÓJ KLUCZ API OPENROUTER.
    // UMIESZCZANIE KLUCZA API BEZPOŚREDNIO W KODZIE KLIENTA (FRONTENDU)
    // JEST BARDZO NIEBEZPIECZNE! KAZDY, KTO OTWORZY KONSOLĘ PRZEGLĄDARKI,
    // BĘDZIE MÓGŁ ZOBACZYĆ I UKRAŚĆ TWÓJ KLUCZ.
    // ZALECAM UŻYCIE TEGO ROZWIĄZANIA TYLKO DO TESTÓW/ROZWOJU LOKALNEGO.
    // DLA APLIKACJI PRODUKCYJNYCH ZAWSZE UŻYWAJ BEZPIECZNEGO BACKENDU,
    // KTÓRY BĘDZIE PRZECHOWYWAŁ KLUCZ API I POŚREDNICZYŁ W KOMUNIKACJI.
    const OPENROUTER_API_KEY = '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'; // <--- TWÓJ KLUCZ API

    // === KONFIGURACJA WEBHOOKA DISCORD ===
    const DISCORD_WEBHOOK_URL = 'https://discord.com/api/webhooks/1371742303135207444/Z8u_qd8gzRufHFEbEs_5jzVwI7TkKqXk6rsEYBpn6NPqhEMXp9d5cc2XMirHGyEwDIHs';
    const VISITS_STORAGE_KEY = 'jurek36ai_local_visits'; // Klucz do przechowywania licznika w localStorage

    const chat = document.getElementById('chat');
    const messageInput = document.getElementById('message');
    const sendBtn = document.getElementById('send');

    let loadingMessageElement = null;
    let currentLanguage = 'pl';
    const CHAT_STORAGE_KEY = 'jurek36ai_chat_history_v2_img_v2';
    let chatHistory = [];

    marked.setOptions({
      breaks: true,
      gfm: true,
    });

    const translations = {
      'pl': {
        systemMessage: 'Jesteś pomocnym asystentem AI o nazwie jurek36AI. Mówisz po polsku. Odpowiadaj zwięźle i na temat. Możesz używać formatowania Markdown.',
        inputPlaceholder: 'Napisz wiadomość lub /obraz <opis>...',
        sendButtonText: 'Wyślij',
        loadingText: 'jurek36AI pisze...',
        imageGeneratingText: 'jurek36AI generuje obraz...',
        errorGeneric: 'Wystąpił nieoczekiwany błąd komunikacji.',
        errorApi: 'Błąd API OpenRouter.',
        errorApiRequest: 'Błędne żądanie (400). Upewnij się, że Twoje żądanie jest poprawna.',
        errorApiAuth: 'Błąd autoryzacji (401). Sprawdź swój klucz API.',
        errorApiQuota: 'Przekroczono limit zapytań (429) lub brak środków. Spróbuj ponownie później lub sprawdź stan konta OpenRouter.',
        errorApiServer: (status) => `Błąd serwera OpenRouter (${status}). Spróbuj ponownie później.`,
        errorMethodNotAllowed: 'Metoda niedozwolona (405). Problem z konfiguracją serwera API. Sprawdź konsolę.',
        errorNoReply: 'Nie otrzymano odpowiedzi tekstowej od bota.',
        errorImageGeneration: 'Błąd podczas generowania obrazu.',
        errorNoImageReturned: 'API nie zwróciło obrazu. Sprawdź konsolę (F12) po więcej szczegółów.',
        errorParsingResponse: 'Błąd parsowania odpowiedzi serwera. Sprawdź konsolę (F12).',
        imageCaptionPrefix: 'Wygenerowany obraz na podstawie opisu:',
        webhookVisitMessage: (count) => `Nowe wejście na stronę! Lokalna liczba wejść z tej przeglądarki: ${count}.`, // Wiadomość na webhooka
        webhookErrorMessage: (error) => `Błąd wysyłania wiadomości na webhooka: ${error}`, // Wiadomość o błędzie webhooka
      },
      'en': {
        systemMessage: 'You are a helpful AI assistant named jurek36AI. You speak English. Respond concisely and to the point. You can use Markdown formatting.',
        inputPlaceholder: 'Write a message or /image <description>...',
        sendButtonText: 'Send',
        loadingText: 'jurek36AI is typing...',
        imageGeneratingText: 'jurek36AI is generating an image...',
        errorGeneric: 'An unexpected communication error occurred.',
        errorApi: 'OpenRouter API Error.',
        errorApiRequest: 'Bad request (400). Ensure your request is correct.',
        errorApiAuth: 'Authorization error (401). Check your API key.',
        errorApiQuota: 'Quota exceeded (429) or out of funds. Try again later or check your OpenRouter account status.',
        errorApiServer: (status) => `OpenRouter Server error (${status}). Please try again later.`,
        errorMethodNotAllowed: 'Method Not Allowed (405). API server configuration issue. Check console.',
        errorNoReply: 'No text reply received from the bot.',
        errorImageGeneration: 'Error generating image.',
        errorNoImageReturned: 'The API did not return an image. Check console (F12) for more details.',
        errorParsingResponse: 'Error parsing server response. Check console (F12).',
        imageCaptionPrefix: 'Generated image based on description:',
        webhookVisitMessage: (count) => `New page visit! Local visits from this browser: ${count}.`, // Webhook message
        webhookErrorMessage: (error) => `Error sending webhook message: ${error}`, // Webhook error message
      }
    };

    // === FUNKCJE OBSŁUGI LICZNIKA WEJŚĆ (LOKALNEGO) ===
    function getLocalVisitsCount() {
        try {
            const count = localStorage.getItem(VISITS_STORAGE_KEY);
            return count ? parseInt(count, 10) : 0;
        } catch (e) {
            console.error("Błąd odczytu licznika z localStorage:", e);
            return 0;
        }
    }

    function incrementLocalVisitsCount() {
        try {
            const currentCount = getLocalVisitsCount();
            const newCount = currentCount + 1;
            localStorage.setItem(VISITS_STORAGE_KEY, newCount);
            return newCount;
        } catch (e) {
            console.error("Błąd zapisu licznika do localStorage:", e);
            return getLocalVisitsCount(); // Zwróć poprzednią wartość, jeśli zapis się nie udał
        }
    }

    // === FUNKCJA WYSYŁAJĄCA WIADOMOŚĆ NA WEBHOOKA ===
    async function sendWebhookMessage(message) {
        try {
            const response = await fetch(DISCORD_WEBHOOK_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    content: message // Treść wiadomości na Discordzie
                    // Możesz dodać inne pola payloadu webhooka, np. username, avatar_url, embeds
                    // username: 'jurek36AI Visit Bot',
                    // avatar_url: 'URL_DO_IKONY',
                }),
            });

            if (!response.ok) {
                console.error(`Błąd HTTP podczas wysyłania na webhooka: ${response.status} ${response.statusText}`);
                const errorText = await response.text();
                console.error('Odpowiedź webhooka:', errorText);
                // Opcjonalnie: wyświetl błąd w konsoli lub w interfejsie
                const langData = translations[currentLanguage] || translations['en'];
                console.error(langData.webhookErrorMessage(`HTTP ${response.status}`));
            } else {
                console.log('Wiadomość na webhooka wysłana pomyślnie.');
            }
        } catch (error) {
            console.error('Błąd sieciowy podczas wysyłania na webhooka:', error);
             const langData = translations[currentLanguage] || translations['en'];
             console.error(langData.webhookErrorMessage(error.message || 'Błąd sieci'));
        }
    }


    function saveChatHistory() {
        try {
            localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify(chatHistory));
        } catch (e) {
            console.error("Błąd podczas zapisywania historii czatu:", e);
        }
    }

    function loadChatHistory() {
        const savedHistory = localStorage.getItem(CHAT_STORAGE_KEY);
        if (savedHistory) {
            try {
                const messages = JSON.parse(savedHistory);
                chat.innerHTML = '';
                chatHistory = [];

                messages.forEach(msg => {
                    if (msg.type === 'image') {
                         const langData = translations[currentLanguage] || translations['en'];
                        appendImage(msg.content, msg.prompt, false);
                        chatHistory.push({
                            role: 'assistant',
                            type: 'image',
                            content: msg.content,
                            prompt: msg.prompt
                        });
                    } else {
                        const contentToSanitize = typeof msg.content === 'string' ? msg.content : '';
                        const sanitizedContent = msg.sender === 'user' ? contentToSanitize : DOMPurify.sanitize(contentToSanitize);
                        appendMessage(sanitizedContent, msg.sender, false);
                         chatHistory.push({ role: msg.role, content: contentToSanitize });
                    }
                });
                setTimeout(() => chat.scrollTop = chat.scrollHeight, 0);
            } catch (e) {
                console.error("Błąd ładowania historii czatu z localStorage:", e);
                localStorage.removeItem(CHAT_STORAGE_KEY);
                chatHistory = [];
            }
        }
    }


    function applyLanguageToUI() {
      const langData = translations[currentLanguage] || translations['en'];
      messageInput.placeholder = langData.inputPlaceholder;
      sendBtn.innerText = langData.sendButtonText;
       loadChatHistory();
    }

    async function detectAndSetLanguage() {
      try {
        const storedLang = localStorage.getItem('jurek36ai_language');
        if (storedLang && translations[storedLang]) {
            currentLanguage = storedLang;
        } else {
            const response = await fetch('https://ipapi.co/json/');
            if (!response.ok) throw new Error(`IP API fetch failed: ${response.status}`);
            const data = await response.json();

            if (data && data.country_code) {
              currentLanguage = data.country_code.toLowerCase() === 'pl' ? 'pl' : 'en';
            } else {
                const browserLang = navigator.language || navigator.userLanguage;
                if (browserLang.toLowerCase().startsWith('pl')) {
                    currentLanguage = 'pl';
                } else {
                    currentLanguage = 'en';
                }
                console.warn('Wykrywanie języka przez IP nie powiodło się. Próba użycia języka przeglądarki:', currentLanguage);
            }
            localStorage.setItem('jurek36ai_language', currentLanguage);
        }
      } catch (error) {
        console.warn('Błąd podczas wykrywania języka, używam domyślnego:', currentLanguage, '. Błąd:', error);
        const browserLang = navigator.language || navigator.userLanguage;
        if (browserLang.toLowerCase().startsWith('pl')) {
            currentLanguage = 'pl';
        } else {
            currentLanguage = 'en';
        }
         console.warn('Użyto języka przeglądarki jako fallback:', currentLanguage);
         localStorage.setItem('jurek36ai_language', currentLanguage);
      } finally {
        applyLanguageToUI();
        loadChatHistory();
      }
    }


    function appendMessage(text, sender, isNewMessage = true) {
      const wrapper = document.createElement('div');
      wrapper.className = `flex ${sender === 'user' ? 'justify-end' : 'justify-start'}`;

      const bubble = document.createElement('div');
      bubble.className = `message-bubble ${sender}`;

      const textToParse = typeof text === 'string' ? text : String(text);

       let htmlContent = marked.parse(textToParse);

      if (sender === 'bot') {
         htmlContent = DOMPurify.sanitize(htmlContent, { USE_PROFILES: { html: true } });
      } else {
         htmlContent = DOMPurify.sanitize(htmlContent, { USE_PROFILES: { html: true } });
      }

      bubble.innerHTML = htmlContent;

      wrapper.appendChild(bubble);
      chat.appendChild(wrapper);
      chat.scrollTop = chat.scrollHeight;
      return bubble;
    }

    function appendImage(imageUrl, prompt, isNewMessage = true) {
        const langData = translations[currentLanguage] || translations['en'];
        const wrapper = document.createElement('div');
        wrapper.className = 'flex justify-start';

        const bubble = document.createElement('div');
        bubble.className = 'message-bubble bot';

        const caption = document.createElement('span');
        caption.className = 'image-caption';
        caption.textContent = `${langData.imageCaptionPrefix} "${prompt}"`;
        bubble.appendChild(caption);

        const img = document.createElement('img');
        img.src = imageUrl;
        img.alt = `${langData.imageCaptionPrefix} ${prompt}`;
        img.onerror = () => {
            caption.textContent = langData.errorImageGeneration + ' (' + (currentLanguage === 'pl' ? 'nie udało się załadować obrazu' : 'failed to load image') + ')';
            img.remove();
        };
        bubble.appendChild(img);

        wrapper.appendChild(bubble);
        chat.appendChild(wrapper);
        chat.scrollTop = chat.scrollHeight;
        return bubble;
    }


    function appendLoadingIndicator(loadingTextKey) {
      const langData = translations[currentLanguage] || translations['en'];
      const text = langData[loadingTextKey] || langData.loadingText;

      const wrapper = document.createElement('div');
      wrapper.className = 'flex justify-start';

      const bubble = document.createElement('div');
      bubble.className = 'message-bubble bot animate-pulse';

      if (text.includes("...")) {
        bubble.innerHTML = `<span class="typing-indicator">${text.replace("...", "").trim().split('').map(char => `<span>${char}</span>`).join('')}<span>.</span><span>.</span><span>.</span></span>`;
      } else {
        bubble.textContent = text;
      }

      wrapper.appendChild(bubble);
      chat.appendChild(wrapper);
      chat.scrollTop = chat.scrollHeight;
      loadingMessageElement = wrapper;
    }

    function removeLoadingIndicator() {
      if (loadingMessageElement && loadingMessageElement.parentNode) {
        loadingMessageElement.remove();
        loadingMessageElement = null;
      }
    }

    async function generateImage(prompt) {
        const langData = translations[currentLanguage] || translations['en'];

        appendMessage(`/obraz ${prompt}`, 'user');
        chatHistory.push({ role: 'user', content: `/obraz ${prompt}` });
        saveChatHistory();

        messageInput.value = '';
        sendBtn.disabled = true;
        messageInput.disabled = true;
        appendLoadingIndicator('imageGeneratingText');

        try {
            const apiEndpoint = 'https://openrouter.ai/api/v1/images/generations';
            const imageModel = 'krea/open-dalle-v1.1:free';

            const fetchOptions = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
                    'X-Title': 'jurek36AI Chatbot Image Gen',
                    'HTTP-Referer': location.href,
                },
                body: JSON.stringify({
                    model: imageModel,
                    prompt: prompt,
                    n: 1,
                    size: "1024x1024"
                })
            };

            console.log('Image Generation Request Options:', JSON.stringify(fetchOptions, null, 2));

            const res = await fetch(apiEndpoint, fetchOptions);

            removeLoadingIndicator();
            const clonedResponse = res.clone();

            if (!res.ok) {
                let errorData;
                const contentType = res.headers.get('content-type');

                if (res.status === 405) {
                    errorData = { error: { message: langData.errorMethodNotAllowed }};
                    const errorText = await clonedResponse.text();
                     console.error('Image Generation API Error 405: Response Text:', errorText);
                } else if (contentType && contentType.includes('application/json')) {
                    try {
                        errorData = await res.json();
                    } catch (jsonError) {
                        console.error('Image Generation API Error: Failed to parse JSON error response:', jsonError);
                        const errorText = await clonedResponse.text();
                        console.error('Image Generation API Error: Non-JSON response text:', errorText);
                         errorData = { error: { message: langData.errorParsingResponse + ` (Status: ${res.status})` } };
                    }
                } else {
                    const errorText = await res.text();
                    console.error('Image Generation API Error: Non-JSON response:', errorText);
                    errorData = { error: { message: `Serwer zwrócił nieoczekiwaną odpowiedź (Status: ${res.status}). Zobacz konsolę.` } };
                }

                console.error('Image Generation API Error Data (parsed or constructed):', errorData);
                let displayErrorMessage = langData.errorImageGeneration;

                if (res.status === 401) displayErrorMessage = langData.errorApiAuth;
                else if (res.status === 405) displayErrorMessage = errorData.error.message;
                else if (res.status === 429) displayErrorMessage = langData.errorApiQuota;
                else if (errorData.error?.message && res.status !== 405) displayErrorMessage += `: ${errorData.error.message}`;
                else if (typeof errorData.detail === 'string') displayErrorMessage += `: ${errorData.detail}`;
                else if (res.status !== 405) displayErrorMessage += ` (Status: ${res.status})`;

                appendMessage(`Błąd: ${displayErrorMessage}`, 'bot');
                chatHistory.push({ role: 'assistant', content: `Błąd: ${displayErrorMessage}` });
                saveChatHistory();
                return;
            }

            let data;
            try {
                data = await res.json();
            } catch (jsonParseError) {
                console.error('Image Generation: Error parsing successful response as JSON:', jsonParseError);
                const responseText = await clonedResponse.text();
                console.error('Image Generation: Successful response text that failed to parse:', responseText);
                appendMessage(`Błąd: ${langData.errorParsingResponse}`, 'bot');
                chatHistory.push({ role: 'assistant', content: `Błąd: ${langData.errorParsingResponse}` });
                saveChatHistory();
                return;
            }

            const imageUrl = data.data && data.data[0] && data.data[0].url;

            if (imageUrl) {
                appendImage(imageUrl, prompt);
                chatHistory.push({
                    role: 'assistant',
                    type: 'image',
                    content: imageUrl,
                    prompt: prompt
                });
                saveChatHistory();
            } else {
                console.warn("API nie zwróciło URL obrazu, chociaż odpowiedź była OK. Dane:", data);
                appendMessage(langData.errorNoImageReturned, 'bot');
                 chatHistory.push({ role: 'assistant', content: langData.errorNoImageReturned });
                saveChatHistory();
            }

        } catch (err) {
            removeLoadingIndicator();
            console.error('Błąd podczas generowania obrazu (zewnętrzny catch block):', err);
            const errorMessage = err.message || langData.errorGeneric;
            appendMessage(`Błąd: ${errorMessage}`, 'bot');
             chatHistory.push({ role: 'assistant', content: `Błąd: ${errorMessage}` });
            saveChatHistory();
        } finally {
            sendBtn.disabled = false;
            messageInput.disabled = false;
            messageInput.focus();
        }
    }


    async function handleUserInput(userInput) {
        const trimmedInput = userInput.trim();
        if (!trimmedInput) return;

        messageInput.value = '';

        if (trimmedInput.toLowerCase().startsWith('/obraz ')) {
            const prompt = trimmedInput.substring(7).trim();
            const langData = translations[currentLanguage] || translations['en'];
            if (prompt) {
                generateImage(prompt);
            } else {

                const errorMsg = langData.inputPlaceholder;
                appendMessage(errorMsg, 'bot');
                 chatHistory.push({ role: 'assistant', content: errorMsg });
                saveChatHistory();
            }
        } else {
            appendMessage(trimmedInput, 'user');
            chatHistory.push({ role: 'user', content: trimmedInput });
            saveChatHistory();

            sendBtn.disabled = true;
            messageInput.disabled = true;
            appendLoadingIndicator('loadingText');

            const langData = translations[currentLanguage] || translations['en'];

            try {
                const apiEndpoint = 'https://openrouter.ai/api/v1/chat/completions';
                const modelToUse = 'meta-llama/llama-4-maverick:free';

                const messagesForApi = [
                    { role: "system", content: langData.systemMessage },
                    ...chatHistory
                        .filter(msg => msg.type !== 'image')
                        .map(msg => ({
                            role: msg.role,
                            content: msg.content
                        }))
                ];

                const fetchOptionsChat = {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
                        'X-Title': 'jurek36AI Chatbot',
                        'HTTP-Referer': location.href,
                    },
                    body: JSON.stringify({
                        model: modelToUse,
                        messages: messagesForApi,
                    })
                };
                console.log('Chat API Request Options:', JSON.stringify(fetchOptionsChat, null, 2));

                const res = await fetch(apiEndpoint, fetchOptionsChat);

                removeLoadingIndicator();
                const clonedChatResponse = res.clone();

                if (!res.ok) {
                     let errorData;
                    const contentType = res.headers.get('content-type');

                    if (res.status === 405) {
                        errorData = { error: { message: langData.errorMethodNotAllowed }};
                         const errorText = await clonedChatResponse.text();
                        console.error('Chat API Error 405: Response Text:', errorText);
                    } else if (contentType && contentType.includes('application/json')) {
                         try {
                            errorData = await res.json();
                        } catch (jsonError) {
                            console.error('Chat API Error: Failed to parse JSON error response:', jsonError);
                            const errorText = await clonedChatResponse.text();
                            console.error('Chat API Error: Non-JSON response text:', errorText);
                             errorData = { error: { message: langData.errorParsingResponse + ` (Status: ${res.status})` } };
                        }
                    } else {
                        const errorText = await res.text();
                        console.error('Chat API Error: Non-JSON response:', errorText);
                        errorData = { error: { message: `Serwer zwrócił nieoczekiwaną odpowiedź (Status: ${res.status}). Zobacz konsolę.` } };
                    }

                    console.error('Chat API Error Data (parsed or constructed):', errorData);
                    let displayErrorMessage = langData.errorApi;
                    if (res.status === 400) displayErrorMessage = langData.errorApiRequest;
                    else if (res.status === 401) displayErrorMessage = langData.errorApiAuth;
                     else if (res.status === 405) displayErrorMessage = errorData.error.message;
                    else if (res.status === 429) displayErrorMessage = langData.errorApiQuota;
                    else if (res.status >= 500) displayErrorMessage = langData.errorApiServer(res.status);
                     else if (errorData.error && errorData.error.message && res.status !== 405) displayErrorMessage = `${langData.errorApi}: ${errorData.error.message} (Status: ${res.status})`;
                    else if (typeof errorData.detail === 'string') displayErrorMessage += `: ${errorData.detail}`;
                    else if (res.status !== 405) displayErrorMessage = `${langData.errorApi}: ${langData.errorGeneric} (Status: ${res.status})`;


                    appendMessage(`Błąd: ${displayErrorMessage}`, 'bot');
                    chatHistory.push({ role: 'assistant', content: `Błąd: ${displayErrorMessage}` });
                    saveChatHistory();
                    return;
                }

                let data;
                try {
                     data = await res.json();
                } catch (jsonParseError) {
                    console.error('Chat API: Error parsing successful response as JSON:', jsonParseError);
                     const responseText = await clonedChatResponse.text();
                    console.error('Chat API: Successful response text that failed to parse:', responseText);
                     appendMessage(`Błąd: ${langData.errorParsingResponse}`, 'bot');
                     chatHistory.push({ role: 'assistant', content: `Błąd: ${langData.errorParsingResponse}` });
                    saveChatHistory();
                    return;
                }


                const reply = data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content;

                if (reply) {
                    appendMessage(reply, 'bot');
                     chatHistory.push({ role: 'assistant', content: reply });
                } else {
                    console.warn("API nie zwróciło treści odpowiedzi (Chat):", data);
                    appendMessage(langData.errorNoReply, 'bot');
                     chatHistory.push({ role: 'assistant', content: langData.errorNoReply });
                }
                saveChatHistory();

            } catch (err) {
                removeLoadingIndicator();
                console.error('Błąd komunikacji z API Chatu (zewnętrzny catch block):', err);
                const errorMessage = err.message || langData.errorGeneric;
                appendMessage(`Błąd: ${errorMessage}`, 'bot');
                 chatHistory.push({ role: 'assistant', content: `Błąd: ${errorMessage}` });
                saveChatHistory();
            } finally {
                sendBtn.disabled = false;
                messageInput.disabled = false;
                messageInput.focus();
            }
        }
    }


    sendBtn.addEventListener('click', () => handleUserInput(messageInput.value));
    messageInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleUserInput(messageInput.value);
      }
    });

    window.addEventListener('beforeunload', saveChatHistory);

    window.onload = () => {
        // Inicjalizacja języka i ładowanie historii
        detectAndSetLanguage();
        messageInput.focus();

        // === LOGIKA WYSYŁANIA NA WEBHOOKA PRZY ŁADOWANIU STRONY ===
        const langData = translations[currentLanguage] || translations['en'];

        // 1. Zwiększ lokalny licznik wejść
        const currentLocalVisits = incrementLocalVisitsCount();

        // 2. Przygotuj wiadomość
        const webhookMessage = langData.webhookVisitMessage(currentLocalVisits);

        // 3. Wyślij wiadomość na webhooka
        sendWebhookMessage(webhookMessage);
        // === KONIEC LOGIKI WEBHOOKA ===
    };
  </script>
</body>
</html>
